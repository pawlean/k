#/usr/bin/env bash
function __k_parse_config() {
    local template k_out lead_char

    # There's probably a beter way to keep the + or @ after tab completion
    case $1 in
    contexts )
        lead_char='+' ;;
    clusters )
        lead_char='@' ;;
    esac

    # Use lead_char in output so each variable has it
    template="{{ range .$1  }}$lead_char{{ .name }} {{ end }}"

    # ${cur##*,} removes everything up to and including ,
    if k_out=$(k config view -o template --template="${template}"); then
        COMPREPLY=( $( compgen -W "${k_out[*]}" -- "${cur##*,}" ) ); compopt -o nospace;
    fi
}
__k_parse_get() {
    # echo $cur ${cur#:}
    local template
    template="${2:-"{{ range .items  }}{{ .metadata.name }} {{ end }}"}"
    local k_out
    if k_out=$(k get -o template --template="${template}" "$1"); then
        # remove the leading : for filtering compgen
        cur=${cur#*:}
        # ${cur##*,} removes everything up to the first comma so ":default,kube" becomes "kube"
        COMPREPLY=( $( compgen -W "${k_out[*]}" -- "${cur##*,}") ); compopt -o nospace;
    fi
}

__k_parse_config_contexts() {
    __k_parse_config "contexts"
}
__k_parse_config_clusters() {
    __k_parse_config "clusters"
}
__k_get_resource_namespace()
{
    __k_parse_get "namespace"
}

__k_handle_kspace() {

    # set -x
    local cur prefix;
    # set the current arg
    # prefix is used if we need to match part of the arg but want to
    # return a complete line. +context:na<tab> should complete namespace
    # but we need the full line to have +context: as part of the prefix
    #
    # _init_completion doesn't like args that start with :
    # so we use _get_comp_words_by_ref and exclude : from COMP_WORDBREAKS
    # ":default" with _init_completion would become prev=: cur=default
    # in this case cur=:default
    _get_comp_words_by_ref -n : cur || return

    # try to find a pattern match for the current argument
    case $cur in
    # start with most specific matches and go toward general matches
    # because case is processed in order
    :*,* | *:*,* )
        # This will match for multiple namespaces
        #
        # remove a leading colon from the prefix
        # because otherwise each tab complete will add it to the front
        # because we're using _get_comp_words_by_ref -n :
        # ${cur#:} removes the shortest leading match which will only be
        # a leading : in this case
        cur=${cur#:}
        # $cur matches *,* so we want our prefix to be
        # everything before the last comma (adding a comma)
        prefix="${cur%,*},"
        # more $cur manipulation happens in this function
        __k_get_resource_namespace
        # add the prefix back to the matched value
        # ${COMPREPLY[@]/#/prefix} will add the current line back to each
        # element in the COMPREPLY array
        # Using ${prefix#*:} removes everything before the : so we make
        # sure we only add the namespaces because : is considered a new arg
        # even though everything before it is part of $cur
        COMPREPLY=( "${COMPREPLY[@]/#/${prefix#*:}}" )
        ;;
    :* )
        # This matches for standalone :namespace
        __k_get_resource_namespace
        ;;
    *:* )
        # This matches for +context:namespace or @cluster:namespace
        [[ $cur == *,* ]] && prefix="${cur%,*},"
        __k_get_resource_namespace
        COMPREPLY=( "${COMPREPLY[@]/#/$prefix}" )
        ;;
    +* )
        # This will match contexts without namespaces
        __k_parse_config_contexts
        ;;
    @* )
        # This will match clusters without namespaces
        __k_parse_config_clusters
        ;;
    * )
        # Don't do anything for arguments not in this list
        ;;
    esac
    # set +x

}

__k_handle_word()
{
    local kspace_words=( : @ + )
    if __k_contains_word "${kspace_words[@]}"; then
        __k_handle_kspace
    fi
    if [[ $c -ge $cword ]]; then
        __k_handle_reply
        return
    fi
    __k_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"
    if [[ "${words[c]}" == -* ]]; then
        __k_handle_flag
    elif __k_contains_word "${words[c]}" "${commands[@]}"; then
        __k_handle_command
    elif [[ $c -eq 0 ]]; then
        __k_handle_command
    elif __k_contains_word "${words[c]}" "${command_aliases[@]}"; then
        # aliashash variable is an associative array which is only supported in bash > 3.
        if [[ -z "${BASH_VERSION}" || "${BASH_VERSINFO[0]}" -gt 3 ]]; then
            words[c]=${aliashash[${words[c]}]}
            __k_handle_command
        else
            __k_handle_noun
        fi
    else
        __k_handle_noun
    fi
    __k_handle_word
}

# This will run the standard kubectl completion script
# kubectl completion bash | sed 's/kubectl/k/g'